/**
Working Polymaker for squares (some optimizations still todo)
**/
    public Mat onCameraFrame(CameraBridgeViewBase.CvCameraViewFrame inputFrame) {
        // TODO CANNY THRESHOLD VALUES
        Imgproc.Canny(inputFrame.gray(), out, 150, 220);
        /*
        Note: adaptive needs large values for gauss to be good for movement
        Mean: 5 & 15 good values
        Gauss:
        * */
        // Imgproc.adaptiveThreshold(inputFrame.gray(), out, 255.0,
        // Imgproc.ADAPTIVE_THRESH_GAUSSIAN_C, Imgproc.THRESH_BINARY_INV, 5,10);
        // Otherwise leak!

        contours.clear();
        blub.clear();

        Imgproc.findContours(out.clone(), contours, new Mat(), Imgproc.RETR_CCOMP,
                Imgproc.CHAIN_APPROX_NONE);
        // Get all 4-vertice polygons from contours:
        for (int i = 0; i < contours.size(); i++) {
            MatOfPoint2f input = new MatOfPoint2f(contours.get(i).toArray());
            // Check area:
            if (128 > (int) input.size().area()) {
                continue;
            }
            Imgproc.approxPolyDP(input, result, input.total() * 0.04,
                    true); // TODO THRESHOLD!
            // Only take contours with ==4 points
            if (result.total() == 4 && Imgproc.isContourConvex(new
                    MatOfPoint(result.toArray()))) {
                blub.add(new MatOfPoint(result.toArray()));
            }
        }
        in = inputFrame.rgba();
        Core.polylines(in, blub, true, new Scalar(255, 0, 0), 2);

        return in;
    }

/**
Working feature detection:
**/
public Mat onCameraFrame(CameraBridgeViewBase.CvCameraViewFrame inputFrame) {
        Imgproc.cvtColor(inputFrame.rgba(), in, Imgproc.COLOR_RGBA2RGB);
        detector.detect(in, keypoints);
        Features2d.drawKeypoints(in, keypoints, out, kpColor, 0);
        Imgproc.cvtColor(out, out, Imgproc.COLOR_RGB2RGBA);
        return out;
    }
FeatureDetector detector;
    DescriptorExtractor extractor;
    DescriptorMatcher matcher;
    MatOfDMatch matches;
    Scalar kpColor;
    MatOfKeyPoint keypoints, templatePoints;
    Mat in, out, template, templateDescriptor, sceneDescriptor;

    // On start, prepare things (instead of in the constructor?):
    public void onCameraViewStarted(int width, int height) {
        // Only needs to be done once:
        detector = FeatureDetector.create(FeatureDetector.BRISK);
        extractor = DescriptorExtractor.create(DescriptorExtractor.BRISK);
        matcher = DescriptorMatcher.create(DescriptorMatcher.BRUTEFORCE_HAMMING);
        // Color for drawing keypoints
        kpColor = new Scalar(255,159,10);
        // Prepare working material (otherwise null pointers!):
        keypoints = new MatOfKeyPoint();
        templatePoints = new MatOfKeyPoint();
        out = new Mat();
        in = new Mat();
        template = new Mat();
        templateDescriptor = new Mat();
        sceneDescriptor = new Mat();
        matches = new MatOfDMatch();
        // Prepare marker:
        Bitmap bMap= BitmapFactory.decodeResource(getResources(),
                R.drawable.marker);
        Utils.bitmapToMat(bMap, template);
        detector.detect(template, templatePoints);
        extractor.compute(template, templatePoints, templateDescriptor);
    }

    public void onCameraViewStopped() {
    }

    /**
     * I think the magic happens here.
     *
     * @param inputFrame
     * @return
     */
    public Mat onCameraFrame(CameraBridgeViewBase.CvCameraViewFrame inputFrame) {
        // Feature detection only works with rgb, so we need to convert (and
        // convert back when returning the finished picture)
        Imgproc.cvtColor(inputFrame.rgba(), in, Imgproc.COLOR_RGBA2RGB);

        // Detect features in camera picture
        detector.detect(in, keypoints);
        // Generate descriptor:
        extractor.compute(in, keypoints, sceneDescriptor);
        // Test:
        if (sceneDescriptor.cols() != templateDescriptor.cols() ||
                sceneDescriptor.type() != templateDescriptor.type()) {
            Log.e(TAG, "First frame error thingy...");
            return inputFrame.gray();
        }
        // Match:
        matcher.match(templateDescriptor, sceneDescriptor, matches);
        // If no matches, return
        if (matches.toList().isEmpty()) {
            Log.e(TAG, "Empty list, next...");
            Features2d.drawKeypoints(in, keypoints, out, kpColor, 0);

            Imgproc.cvtColor(out, out, Imgproc.COLOR_RGB2RGBA);
            return out;
        }
        // Draw match
        Features2d.drawMatches(template, templatePoints, in, keypoints,
                matches, out, kpColor, new Scalar(-1), new MatOfByte(), 0);
        // Scale output back to 1280x720:
        Imgproc.resize(out, out, inputFrame.rgba().size(), 0,0,
                Imgproc.INTER_AREA);

        // Convert back:
        Imgproc.cvtColor(out, out, Imgproc.COLOR_RGB2RGBA);
        return out;
    }
